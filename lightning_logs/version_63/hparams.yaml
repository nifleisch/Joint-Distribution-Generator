batch_size: 64
covariance: !!python/object/apply:torch._utils._rebuild_tensor_v2
- !!python/object/apply:torch.storage._load_from_bytes
  - !!binary |
    gAKKCmz8nEb5IGqoUBkugAJN6QMugAJ9cQAoWBAAAABwcm90b2NvbF92ZXJzaW9ucQFN6QNYDQAA
    AGxpdHRsZV9lbmRpYW5xAohYCgAAAHR5cGVfc2l6ZXNxA31xBChYBQAAAHNob3J0cQVLAlgDAAAA
    aW50cQZLBFgEAAAAbG9uZ3EHSwR1dS6AAihYBwAAAHN0b3JhZ2VxAGN0b3JjaApGbG9hdFN0b3Jh
    Z2UKcQFYCgAAADYzODA5NzY2MjRxAlgDAAAAY3B1cQNLkE50cQRRLoACXXEAWAoAAAA2MzgwOTc2
    NjI0cQFhLpAAAAAAAAAAAACAPykmPz/SxiA/UaNFPx2RaD/aVkE/HocvPzcEBj9HiDM/EbdgP8NW
    UD9or1E/KCY/P/7/fz9w/kc/jT8/P7PnOT8tEFc/x0FbPyavND+EbEg/RUViP0fpWz8MbCo/0cYg
    P3D+Rz8BAIA/Tfc4P3VbSj/J/zg/Z7dPP5PnMz8U8gk/VIYmP1UXRz/BWx8/UaNFP40/Pz9N9zg/
    AACAP/7mNj9R7kQ/6XdDPzHfNj+n0x4/lqwqP6pKPz9A50o/HJFoP7PnOT91W0o//uY2P/7/fz+5
    YTw/fpI4PxuSKT+e/Ck/3chWP57STz9yv0Q/2lZBPy0QVz/J/zg/Uu5EP7lhPD8AAIA/rExlP42u
    KD+7whw/SmhcP6YwRD8qmws/HocvP8dBWz9mt08/6HdDP36SOD+rTGU///9/P/2MSz9yUAE/1aND
    Pwh/Oz84QBY/NwQGPyWvND+T5zM/Md82PxuSKT+Nrig//oxLPwAAgD8/fQc/hZAhPyCuFj9Wjx4/
    R4gzP4RsSD8U8gk/qNMeP578KT+7whw/clABPz99Bz8BAIA/rC5UP+7HOD93PB0/EbdgP0VFYj9U
    hiY/lqwqP97IVj9KaFw/1aNDP4SQIT+rLlQ///9/P3dXUT8gZSI/w1ZQP0jpWz9UF0c/qUo/P53S
    Tz+lMEQ/CH87Px+uFj/vxzg/d1dRPwEAgD/b6T8/aa9RPwxsKj/BWx8/QOdKP3G/RD8rmws/OEAW
    P1aPHj94PB0/IGUiP9vpPz///38/
- 0
- !!python/tuple
  - 12
  - 12
- !!python/tuple
  - 12
  - 1
- false
- !!python/object/apply:collections.OrderedDict
  - []
d_latents: 24
distributions:
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: -.inf
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.norm_gen
    __doc__: "A normal continuous random variable.\n\n    The location (``loc``) keyword\
      \ specifies the mean.\n    The scale (``scale``) keyword specifies the standard\
      \ deviation.\n\n    As an instance of the `rv_continuous` class, `norm` object\
      \ inherits from it\n    a collection of generic methods (see below for the full\
      \ list),\n    and completes them with details specific for this particular distribution.\n\
      \    \n    Methods\n    -------\n    rvs(loc=0, scale=1, size=1, random_state=None)\n\
      \        Random variates.\n    pdf(x, loc=0, scale=1)\n        Probability density\
      \ function.\n    logpdf(x, loc=0, scale=1)\n        Log of the probability density\
      \ function.\n    cdf(x, loc=0, scale=1)\n        Cumulative distribution function.\n\
      \    logcdf(x, loc=0, scale=1)\n        Log of the cumulative distribution function.\n\
      \    sf(x, loc=0, scale=1)\n        Survival function  (also defined as ``1\
      \ - cdf``, but `sf` is sometimes more accurate).\n    logsf(x, loc=0, scale=1)\n\
      \        Log of the survival function.\n    ppf(q, loc=0, scale=1)\n       \
      \ Percent point function (inverse of ``cdf`` --- percentiles).\n    isf(q, loc=0,\
      \ scale=1)\n        Inverse survival function (inverse of ``sf``).\n    moment(order,\
      \ loc=0, scale=1)\n        Non-central moment of the specified order.\n    stats(loc=0,\
      \ scale=1, moments='mv')\n        Mean('m'), variance('v'), skew('s'), and/or\
      \ kurtosis('k').\n    entropy(loc=0, scale=1)\n        (Differential) entropy\
      \ of the RV.\n    fit(data)\n        Parameter estimates for generic data.\n\
      \        See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n  \
      \      Expected value of a function (of one argument) with respect to the distribution.\n\
      \    median(loc=0, scale=1)\n        Median of the distribution.\n    mean(loc=0,\
      \ scale=1)\n        Mean of the distribution.\n    var(loc=0, scale=1)\n   \
      \     Variance of the distribution.\n    std(loc=0, scale=1)\n        Standard\
      \ deviation of the distribution.\n    interval(confidence, loc=0, scale=1)\n\
      \        Confidence interval with equal areas around the median.\n\n    Notes\n\
      \    -----\n    The probability density function for `norm` is:\n\n    .. math::\n\
      \n        f(x) = \\frac{\\exp(-x^2/2)}{\\sqrt{2\\pi}}\n\n    for a real number\
      \ :math:`x`.\n\n    The probability density above is defined in the \"standardized\"\
      \ form. To shift\n    and/or scale the distribution use the ``loc`` and ``scale``\
      \ parameters.\n    Specifically, ``norm.pdf(x, loc, scale)`` is identically\n\
      \    equivalent to ``norm.pdf(y) / scale`` with\n    ``y = (x - loc) / scale``.\
      \ Note that shifting the location of a distribution\n    does not make it a\
      \ \"noncentral\" distribution; noncentral generalizations of\n    some distributions\
      \ are available in separate classes.\n\n    Examples\n    --------\n    >>>\
      \ import numpy as np\n    >>> from scipy.stats import norm\n    >>> import matplotlib.pyplot\
      \ as plt\n    >>> fig, ax = plt.subplots(1, 1)\n    \n    Calculate the first\
      \ four moments:\n    \n    \n    >>> mean, var, skew, kurt = norm.stats(moments='mvsk')\n\
      \    \n    Display the probability density function (``pdf``):\n    \n    >>>\
      \ x = np.linspace(norm.ppf(0.01),\n    ...                 norm.ppf(0.99), 100)\n\
      \    >>> ax.plot(x, norm.pdf(x),\n    ...        'r-', lw=5, alpha=0.6, label='norm\
      \ pdf')\n    \n    Alternatively, the distribution object can be called (as\
      \ a function)\n    to fix the shape, location and scale parameters. This returns\
      \ a \"frozen\"\n    RV object holding the given parameters fixed.\n    \n  \
      \  Freeze the distribution and display the frozen ``pdf``:\n    \n    >>> rv\
      \ = norm()\n    >>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')\n\
      \    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> vals = norm.ppf([0.001,\
      \ 0.5, 0.999])\n    >>> np.allclose([0.001, 0.5, 0.999], norm.cdf(vals))\n \
      \   True\n    \n    Generate random numbers:\n    \n    >>> r = norm.rvs(size=1000)\n\
      \    \n    And compare the histogram:\n    \n    >>> ax.hist(r, density=True,\
      \ bins='auto', histtype='stepfilled', alpha=0.2)\n    >>> ax.set_xlim([x[0],\
      \ x[-1]])\n    >>> ax.legend(loc='best', frameon=False)\n    >>> plt.show()\n\
      \    \n\n    "
    _ctor_param:
      a: -.inf
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: norm
      seed: null
      shapes: null
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self,  loc=0, scale=1):\n    return (),\
      \ loc, scale\n\ndef _parse_args_rvs(self,  loc=0, scale=1, size=None):\n   \
      \ return self._argcheck_rvs( loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \  loc=0, scale=1, moments='mv'):\n    return (), loc, scale, moments\n"
    _random_state: &id001 !!python/object/apply:numpy.random._pickle.__randomstate_ctor
      args:
      - MT19937
      - !!python/name:numpy.random._pickle.__bit_generator_ctor ''
      state:
        bit_generator: MT19937
        gauss: 0.0
        has_gauss: 0
        state:
          key: !!python/object/apply:numpy.core.multiarray._reconstruct
            args:
            - !!python/name:numpy.ndarray ''
            - !!python/tuple
              - 0
            - !!binary |
              Yg==
            state: !!python/tuple
            - 1
            - !!python/tuple
              - 624
            - !!python/object/apply:numpy.dtype
              args:
              - u4
              - false
              - true
              state: !!python/tuple
              - 3
              - <
              - null
              - null
              - null
              - -1
              - -1
              - 0
            - false
            - !!binary |
              AAAAgLIeijTOskWsr4DAM5zkHTEKJIJXcod5o5douNzNFQy5LzP3fG8uJKcYa/dL/35+8isegwLt
              fib8n08w1qj8aU/EhTx7XY9WSxRo++diiGN/D/hHBAEMiv2Sej12B6NG/QsEk7jw8TvPtWragx3P
              HKHxwZkzi1HAMWf4SA6wZvE7PdOFLQKRiUBb7TTF5i1nVWTnbB0uCCX3U+d8ogJSwz1DtxvDkXva
              B0SWqwd6Qvvt29zzL1HpmjRavPWiDkDPbuzPlPz13P6D/sIRAvyR/YOxwHmiZmLt7kl85iFtQyxa
              8/vr+vrAMflADy+VcZ9wlo9JZ9uB+8oIxXvqLCm2aNa0p4y6TN7H8go+ZeewIzFwWgLSaN4L1ZEP
              HCD6nIxdZjcy79CENc8CEbP+QT3evNSiRQr2/uk12SNUjMuzgXKolJZsJ/Zq/TBoq4fq61Lqp6Oe
              621NR8ag4VpOaHZwN2wkA7wM+HMz52IpDUZ8BX1pqnDCOQ7QRV4QGj/yRWAEe8mKcY/yyXkuIWRO
              3ilzqN0bQhPz8JL7f7HsngcmaufHcJAoCwMcSFZ5+JbvKOepAnogUmoeCNWDQiDtkARIxSTpy5Ex
              NBs/tnlxlgMy4zPzVu6ed9GgWlqmhgmFJmNntJLwihglze6Kk2/8Hy0rLCxS6rr/+gixoWG6ThPD
              fIJiQ0176W655aOGHel25xNmwjcPv8JcY1fr8cPefxyS3bop9fF81PKfNwkp5jFqE+ub9p1eq6oF
              Ydv2cllj0jITVSCd2GV7znBmqPdH8H7xfwKSo9p1tdQ+gc5bYR/ou6lhY2/7GcWjDmHDZazElbOU
              kUT1LHlUXR+BGQ02owmVSEwVb60Xamfh0qohxYHo2Gn0qbqh7nFjegBZTXYwYc2g7rBN6OO2J/3H
              dv6ZN6XbJLgG5y7q/+A02f43UaHYEBm6Lm5WQxtGEAVGHKkkQj1DM7AXeCu37zxn6kZFk/QAtZXl
              uv0B6bgiJdC/v323NrYztFFcjaiI4395eVZG+CG5Ndfo7389mrZyZzcItivDqowBdYmxLzAkZm9R
              QF87MfpXlCdMO1jpE3r6GxXxZ4rmNAylpGhPyYTdsx8cSMc8BpmCiHojvJK3pOC5D8DyivMj5QGt
              fGxy59EZvrYkq2bqtnU97fSubGW8qi7FiQx3DVe7A9OQiBrDEEqPZS9KjAsbJ0afORi9k353EBgi
              yqJLCKjLoMB1pH7Vxsvp6K29bNxFxx0Sq5HgH7U5Wqbtymwrs7mb3fWlPkIGl6n/jLNNkzrtQhnq
              f+HOJZDKOhiXGZtEYIwDzHRHCkbI6TPg7qG9F2YPxLjPc2QF/mrWmGuZ0PaeHgGK58HCcRxeLUvl
              CjdUmGyGEZuaZbE13kb3Znbjr/8n2M/zxLeb67TfFlfXi91iBaGQEts7pjhJ6K/rLteQ6ji6A+TI
              Jj8/kPaWmld5iwVz94sdgJmAgW++RXFE1v55thkUdp9nxjhpdEREBcoHd59H3u8V8Ya26S/l+OTm
              Qr4qaDMIeMj8xtNg4l2j0DVgjZKQKBuZhdLqii3TrPt8a3TFoO+rsJYSuWenI2a8T94XNteenMKw
              P1/OJoSn24lHoWBScZlscindZ4igSf4Z/mHZUNtbJCuNxM04EjnQGqLSZH1D9q9hGc4U4uWjrJTl
              jJA14v47hMnrM14xX4hzQZs39J6/zf+Y0C8XjVYdkniqaYcKDMbNnKIl9812zsvfQ8E5mTIjAa0u
              61y5naOy7Wq73mGVljeF2KfCdEPOOPCQF4r5QamqdQWqydsIgiFs2cm0mr+ANd7aL6IMo6neXZYK
              wV9KWP3eUswPMU59q2Iz4evTIOdXzjjhjFmNRcGcqbFeYhWMBbMqKz9CfgkDE7v6eGbz4dsptMPI
              b0kxsli6PQJBCQwlIQrqIxHizKn98fJ7ETD7/7AQZ9hDWdaLWKMmbwekrLu2FNZW6Zd11qiuNkU6
              TrdkhovUtqO3Y0xdhGB/0PSKfYLSsVqyG7XgJfh5f3m0Xhxwc1Dyg/M0B2LvW9GrmqJv60BCie7I
              oKvQk5j5rXJ3tJXbfgJVg9RHIM+heZlyMe0xwl21GXRBl/hPBRrWUXN3e5izOlW7bbi7ENF+47Ud
              Ou+VHsCHARDa9iIq4Efrz/WwGgeBooAB6WmhU8jOQ7vxnV7ZyLSJvqYCPuh+u7U59jKZM6Zmp7RC
              ESphdQk+Fejjx83qqqujvrMG7/PIeF1mygnK0ApR1geiD6pEv098vDKTTxIU00cFk12x1HGfschx
              J9gtfqxt5kTOBf7oNbHHqGjugvtDIc4ttvy2Gb36iStm07LIs3YEVsz2tEs/g8A5bzxx9zAyD8MX
              7FwflyLDv6xN6LTpARYS/gIFrk6ZpXGKHua6p/7L/vPFVyzc5O9GgHcfd56Ii8oD4lKwWSb8KdOX
              /Eo93ObUPkRbSRB68OUf/+/SbrxBjul/q+Fg1WOUzEOZNFjh0sgqRwtcAIrWHDm1HaAc+ds+kw8X
              Gpz5qYYGzEPjAuNFLN0Rwf4KThKtfYr5V/iHko36SjxWd3zVU/rT5BSl07q3AtQNXIY/SkUlt43U
              DI5/J3dImoGRMDqOFY2m1WdEqT3xxE1VBhuED2vAcdbwR9lB8Ql1477k3yNwO3rku7SPCPeQRRtO
              akm4prK8bb3RWPWQ4kOFyDvC7W02pX3k/rzlpCOnz2xEuHXXLfRt9QbW6z44cps53o3QorGAX8Fd
              nUKlgIuXAAmjO8yYglQDYdGkWS/uSOXs1pf5864ebxLPbxeI20+QRpFlflV8Kv3GIVmJbT/U9Dby
              gl0rw0cCVFJlqrMW/R2ZR2eoWEQGRVFb9xPjk3sYCqXqCpalBOS6OuaisgxAx/5K7iUXFlwXktZY
              vlKrHeD90+b8AEQ7BYahPRnrFTeeRojU5+zFAkTaDXMFIbkSsm26t5UCeEK5jUAkGCj/QLS8hUxq
              7WJI40c4uRCyod1q4NWKeqSy/HNy4X2ZttYx3e75vRbNO4k6+6Lwaoo1Zb5phIIrj1+QHumNCZWQ
              6BUjjJ3i8khuIG9Jr3ZH3ABgSxMsGwN8JeNkI1+zZwakNC+Y/3eQnkeuxh35/XF/eYpykH46UcxN
              voz0QHqYAPA5u64QWf/72phb8nB82HcoC+ObW2H07n+uvicvtdc8V8lcc9nfNo7tYew0UXYZffiu
              c8kM+KO6tMX1ufrjYkTxrDq4ojrNZZkXmNvgTogvFeJe7D/zEAvpnqjlwfd5Kpm6Ev1oGwdxi04K
              QHyFdEy/UbQ82N73JT9B/kzdDIU/2UaSjPQaG51c592iTlNmMdmREnpSjv0u
          pos: 623
    _stats_has_moments: false
    a: -.inf
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: norm
    numargs: 0
    shapes: null
    xtol: 1.0e-14
  kwds:
    loc: -3
    scale: 1.7
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: 1.0
  dist: !!python/object:scipy.stats._continuous_distns.uniform_gen
    __doc__: "A uniform continuous random variable.\n\n    In the standard form, the\
      \ distribution is uniform on ``[0, 1]``. Using\n    the parameters ``loc`` and\
      \ ``scale``, one obtains the uniform distribution\n    on ``[loc, loc + scale]``.\n\
      \n    As an instance of the `rv_continuous` class, `uniform` object inherits\
      \ from it\n    a collection of generic methods (see below for the full list),\n\
      \    and completes them with details specific for this particular distribution.\n\
      \    \n    Methods\n    -------\n    rvs(loc=0, scale=1, size=1, random_state=None)\n\
      \        Random variates.\n    pdf(x, loc=0, scale=1)\n        Probability density\
      \ function.\n    logpdf(x, loc=0, scale=1)\n        Log of the probability density\
      \ function.\n    cdf(x, loc=0, scale=1)\n        Cumulative distribution function.\n\
      \    logcdf(x, loc=0, scale=1)\n        Log of the cumulative distribution function.\n\
      \    sf(x, loc=0, scale=1)\n        Survival function  (also defined as ``1\
      \ - cdf``, but `sf` is sometimes more accurate).\n    logsf(x, loc=0, scale=1)\n\
      \        Log of the survival function.\n    ppf(q, loc=0, scale=1)\n       \
      \ Percent point function (inverse of ``cdf`` --- percentiles).\n    isf(q, loc=0,\
      \ scale=1)\n        Inverse survival function (inverse of ``sf``).\n    moment(order,\
      \ loc=0, scale=1)\n        Non-central moment of the specified order.\n    stats(loc=0,\
      \ scale=1, moments='mv')\n        Mean('m'), variance('v'), skew('s'), and/or\
      \ kurtosis('k').\n    entropy(loc=0, scale=1)\n        (Differential) entropy\
      \ of the RV.\n    fit(data)\n        Parameter estimates for generic data.\n\
      \        See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n  \
      \      Expected value of a function (of one argument) with respect to the distribution.\n\
      \    median(loc=0, scale=1)\n        Median of the distribution.\n    mean(loc=0,\
      \ scale=1)\n        Mean of the distribution.\n    var(loc=0, scale=1)\n   \
      \     Variance of the distribution.\n    std(loc=0, scale=1)\n        Standard\
      \ deviation of the distribution.\n    interval(confidence, loc=0, scale=1)\n\
      \        Confidence interval with equal areas around the median.\n\n    Examples\n\
      \    --------\n    >>> import numpy as np\n    >>> from scipy.stats import uniform\n\
      \    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(1,\
      \ 1)\n    \n    Calculate the first four moments:\n    \n    \n    >>> mean,\
      \ var, skew, kurt = uniform.stats(moments='mvsk')\n    \n    Display the probability\
      \ density function (``pdf``):\n    \n    >>> x = np.linspace(uniform.ppf(0.01),\n\
      \    ...                 uniform.ppf(0.99), 100)\n    >>> ax.plot(x, uniform.pdf(x),\n\
      \    ...        'r-', lw=5, alpha=0.6, label='uniform pdf')\n    \n    Alternatively,\
      \ the distribution object can be called (as a function)\n    to fix the shape,\
      \ location and scale parameters. This returns a \"frozen\"\n    RV object holding\
      \ the given parameters fixed.\n    \n    Freeze the distribution and display\
      \ the frozen ``pdf``:\n    \n    >>> rv = uniform()\n    >>> ax.plot(x, rv.pdf(x),\
      \ 'k-', lw=2, label='frozen pdf')\n    \n    Check accuracy of ``cdf`` and ``ppf``:\n\
      \    \n    >>> vals = uniform.ppf([0.001, 0.5, 0.999])\n    >>> np.allclose([0.001,\
      \ 0.5, 0.999], uniform.cdf(vals))\n    True\n    \n    Generate random numbers:\n\
      \    \n    >>> r = uniform.rvs(size=1000)\n    \n    And compare the histogram:\n\
      \    \n    >>> ax.hist(r, density=True, bins='auto', histtype='stepfilled',\
      \ alpha=0.2)\n    >>> ax.set_xlim([x[0], x[-1]])\n    >>> ax.legend(loc='best',\
      \ frameon=False)\n    >>> plt.show()\n    \n\n    "
    _ctor_param:
      a: 0.0
      b: 1.0
      badvalue: .nan
      longname: null
      momtype: 1
      name: uniform
      seed: null
      shapes: null
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self,  loc=0, scale=1):\n    return (),\
      \ loc, scale\n\ndef _parse_args_rvs(self,  loc=0, scale=1, size=None):\n   \
      \ return self._argcheck_rvs( loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \  loc=0, scale=1, moments='mv'):\n    return (), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0.0
    b: 1.0
    badvalue: .nan
    moment_type: 1
    name: uniform
    numargs: 0
    shapes: null
    xtol: 1.0e-14
  kwds:
    loc: 5.3
    scale: 10.7
- !!python/object:scipy.stats._distn_infrastructure.rv_discrete_frozen
  a: 0
  args: !!python/tuple []
  b: 1
  dist: &id002 !!python/object:scipy.stats._discrete_distns.bernoulli_gen
    __doc__: "A Bernoulli discrete random variable.\n\n    As an instance of the `rv_discrete`\
      \ class, `bernoulli` object inherits from it\n    a collection of generic methods\
      \ (see below for the full list),\n    and completes them with details specific\
      \ for this particular distribution.\n    \n    Methods\n    -------\n    rvs(p,\
      \ loc=0, size=1, random_state=None)\n        Random variates.\n    pmf(k, p,\
      \ loc=0)\n        Probability mass function.\n    logpmf(k, p, loc=0)\n    \
      \    Log of the probability mass function.\n    cdf(k, p, loc=0)\n        Cumulative\
      \ distribution function.\n    logcdf(k, p, loc=0)\n        Log of the cumulative\
      \ distribution function.\n    sf(k, p, loc=0)\n        Survival function  (also\
      \ defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n    logsf(k,\
      \ p, loc=0)\n        Log of the survival function.\n    ppf(q, p, loc=0)\n \
      \       Percent point function (inverse of ``cdf`` --- percentiles).\n    isf(q,\
      \ p, loc=0)\n        Inverse survival function (inverse of ``sf``).\n    stats(p,\
      \ loc=0, moments='mv')\n        Mean('m'), variance('v'), skew('s'), and/or\
      \ kurtosis('k').\n    entropy(p, loc=0)\n        (Differential) entropy of the\
      \ RV.\n    expect(func, args=(p,), loc=0, lb=None, ub=None, conditional=False)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(p, loc=0)\n        Median of the distribution.\n\
      \    mean(p, loc=0)\n        Mean of the distribution.\n    var(p, loc=0)\n\
      \        Variance of the distribution.\n    std(p, loc=0)\n        Standard\
      \ deviation of the distribution.\n    interval(confidence, p, loc=0)\n     \
      \   Confidence interval with equal areas around the median.\n\n    Notes\n \
      \   -----\n    The probability mass function for `bernoulli` is:\n\n    .. math::\n\
      \n       f(k) = \\begin{cases}1-p  &\\text{if } k = 0\\\\\n                \
      \           p    &\\text{if } k = 1\\end{cases}\n\n    for :math:`k` in :math:`\\\
      {0, 1\\}`, :math:`0 \\leq p \\leq 1`\n\n    `bernoulli` takes :math:`p` as shape\
      \ parameter,\n    where :math:`p` is the probability of a single success\n \
      \   and :math:`1-p` is the probability of a single failure.\n\n    The probability\
      \ mass function above is defined in the \"standardized\" form.\n    To shift\
      \ distribution use the ``loc`` parameter.\n    Specifically, ``bernoulli.pmf(k,\
      \ p, loc)`` is identically\n    equivalent to ``bernoulli.pmf(k - loc, p)``.\n\
      \n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.stats\
      \ import bernoulli\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax\
      \ = plt.subplots(1, 1)\n    \n    Calculate the first four moments:\n    \n\
      \    >>> p = 0.3\n    >>> mean, var, skew, kurt = bernoulli.stats(p, moments='mvsk')\n\
      \    \n    Display the probability mass function (``pmf``):\n    \n    >>> x\
      \ = np.arange(bernoulli.ppf(0.01, p),\n    ...               bernoulli.ppf(0.99,\
      \ p))\n    >>> ax.plot(x, bernoulli.pmf(x, p), 'bo', ms=8, label='bernoulli\
      \ pmf')\n    >>> ax.vlines(x, 0, bernoulli.pmf(x, p), colors='b', lw=5, alpha=0.5)\n\
      \    \n    Alternatively, the distribution object can be called (as a function)\n\
      \    to fix the shape and location. This returns a \"frozen\" RV object holding\n\
      \    the given parameters fixed.\n    \n    Freeze the distribution and display\
      \ the frozen ``pmf``:\n    \n    >>> rv = bernoulli(p)\n    >>> ax.vlines(x,\
      \ 0, rv.pmf(x), colors='k', linestyles='-', lw=1,\n    ...         label='frozen\
      \ pmf')\n    >>> ax.legend(loc='best', frameon=False)\n    >>> plt.show()\n\
      \    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> prob = bernoulli.cdf(x,\
      \ p)\n    >>> np.allclose(x, bernoulli.ppf(prob, p))\n    True\n    \n    Generate\
      \ random numbers:\n    \n    >>> r = bernoulli.rvs(p, size=1000)\n\n    "
    _ctor_param:
      a: 0
      b: 1
      badvalue: .nan
      inc: 1
      longname: null
      moment_tol: 1.0e-08
      name: bernoulli
      seed: null
      shapes: p
      values: null
    _parse_arg_template: "\ndef _parse_args(self, p,  loc=0):\n    return (p, ), loc,\
      \ 1\n\ndef _parse_args_rvs(self, p,  loc=0, size=None):\n    return self._argcheck_rvs(p,\
      \  loc, 1, size=size)\n\ndef _parse_args_stats(self, p,  loc=0, moments='mv'):\n\
      \    return (p, ), loc, 1, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0
    b: 1
    badvalue: .nan
    inc: 1
    moment_tol: 1.0e-08
    name: bernoulli
    numargs: 1
    shapes: p
    vecentropy: !!python/object:numpy.vectorize
      __doc__: null
      __name__: _entropy
      _doc: null
      _in_and_out_core_dims: null
      _ufunc: {}
      cache: false
      excluded: !!set {}
      otypes: null
      pyfunc: !!python/object/apply:builtins.getattr
      - *id002
      - _entropy
      signature: null
  kwds:
    p: 0.314
- !!python/object:scipy.stats._distn_infrastructure.rv_discrete_frozen
  a: 0
  args: !!python/tuple []
  b: 10
  dist: &id003 !!python/object:scipy.stats._discrete_distns.binom_gen
    __doc__: "A binomial discrete random variable.\n\n    As an instance of the `rv_discrete`\
      \ class, `binom` object inherits from it\n    a collection of generic methods\
      \ (see below for the full list),\n    and completes them with details specific\
      \ for this particular distribution.\n    \n    Methods\n    -------\n    rvs(n,\
      \ p, loc=0, size=1, random_state=None)\n        Random variates.\n    pmf(k,\
      \ n, p, loc=0)\n        Probability mass function.\n    logpmf(k, n, p, loc=0)\n\
      \        Log of the probability mass function.\n    cdf(k, n, p, loc=0)\n  \
      \      Cumulative distribution function.\n    logcdf(k, n, p, loc=0)\n     \
      \   Log of the cumulative distribution function.\n    sf(k, n, p, loc=0)\n \
      \       Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes\
      \ more accurate).\n    logsf(k, n, p, loc=0)\n        Log of the survival function.\n\
      \    ppf(q, n, p, loc=0)\n        Percent point function (inverse of ``cdf``\
      \ --- percentiles).\n    isf(q, n, p, loc=0)\n        Inverse survival function\
      \ (inverse of ``sf``).\n    stats(n, p, loc=0, moments='mv')\n        Mean('m'),\
      \ variance('v'), skew('s'), and/or kurtosis('k').\n    entropy(n, p, loc=0)\n\
      \        (Differential) entropy of the RV.\n    expect(func, args=(n, p), loc=0,\
      \ lb=None, ub=None, conditional=False)\n        Expected value of a function\
      \ (of one argument) with respect to the distribution.\n    median(n, p, loc=0)\n\
      \        Median of the distribution.\n    mean(n, p, loc=0)\n        Mean of\
      \ the distribution.\n    var(n, p, loc=0)\n        Variance of the distribution.\n\
      \    std(n, p, loc=0)\n        Standard deviation of the distribution.\n   \
      \ interval(confidence, n, p, loc=0)\n        Confidence interval with equal\
      \ areas around the median.\n\n    Notes\n    -----\n    The probability mass\
      \ function for `binom` is:\n\n    .. math::\n\n       f(k) = \\binom{n}{k} p^k\
      \ (1-p)^{n-k}\n\n    for :math:`k \\in \\{0, 1, \\dots, n\\}`, :math:`0 \\leq\
      \ p \\leq 1`\n\n    `binom` takes :math:`n` and :math:`p` as shape parameters,\n\
      \    where :math:`p` is the probability of a single success\n    and :math:`1-p`\
      \ is the probability of a single failure.\n\n    The probability mass function\
      \ above is defined in the \"standardized\" form.\n    To shift distribution\
      \ use the ``loc`` parameter.\n    Specifically, ``binom.pmf(k, n, p, loc)``\
      \ is identically\n    equivalent to ``binom.pmf(k - loc, n, p)``.\n\n    Examples\n\
      \    --------\n    >>> import numpy as np\n    >>> from scipy.stats import binom\n\
      \    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(1,\
      \ 1)\n    \n    Calculate the first four moments:\n    \n    >>> n, p = 5, 0.4\n\
      \    >>> mean, var, skew, kurt = binom.stats(n, p, moments='mvsk')\n    \n \
      \   Display the probability mass function (``pmf``):\n    \n    >>> x = np.arange(binom.ppf(0.01,\
      \ n, p),\n    ...               binom.ppf(0.99, n, p))\n    >>> ax.plot(x, binom.pmf(x,\
      \ n, p), 'bo', ms=8, label='binom pmf')\n    >>> ax.vlines(x, 0, binom.pmf(x,\
      \ n, p), colors='b', lw=5, alpha=0.5)\n    \n    Alternatively, the distribution\
      \ object can be called (as a function)\n    to fix the shape and location. This\
      \ returns a \"frozen\" RV object holding\n    the given parameters fixed.\n\
      \    \n    Freeze the distribution and display the frozen ``pmf``:\n    \n \
      \   >>> rv = binom(n, p)\n    >>> ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-',\
      \ lw=1,\n    ...         label='frozen pmf')\n    >>> ax.legend(loc='best',\
      \ frameon=False)\n    >>> plt.show()\n    \n    Check accuracy of ``cdf`` and\
      \ ``ppf``:\n    \n    >>> prob = binom.cdf(x, n, p)\n    >>> np.allclose(x,\
      \ binom.ppf(prob, n, p))\n    True\n    \n    Generate random numbers:\n   \
      \ \n    >>> r = binom.rvs(n, p, size=1000)\n\n    See Also\n    --------\n \
      \   hypergeom, nbinom, nhypergeom\n\n    "
    _ctor_param:
      a: 0
      b: .inf
      badvalue: .nan
      inc: 1
      longname: null
      moment_tol: 1.0e-08
      name: binom
      seed: null
      shapes: n, p
      values: null
    _parse_arg_template: "\ndef _parse_args(self, n, p,  loc=0):\n    return (n, p,\
      \ ), loc, 1\n\ndef _parse_args_rvs(self, n, p,  loc=0, size=None):\n    return\
      \ self._argcheck_rvs(n, p,  loc, 1, size=size)\n\ndef _parse_args_stats(self,\
      \ n, p,  loc=0, moments='mv'):\n    return (n, p, ), loc, 1, moments\n"
    _random_state: *id001
    _stats_has_moments: true
    a: 0
    b: .inf
    badvalue: .nan
    inc: 1
    moment_tol: 1.0e-08
    name: binom
    numargs: 2
    shapes: n, p
    vecentropy: !!python/object:numpy.vectorize
      __doc__: null
      __name__: _entropy
      _doc: null
      _in_and_out_core_dims: null
      _ufunc: {}
      cache: false
      excluded: !!set {}
      otypes: null
      pyfunc: !!python/object/apply:builtins.getattr
      - *id003
      - _entropy
      signature: null
  kwds:
    n: 10
    p: 0.42
- !!python/object:scipy.stats._distn_infrastructure.rv_discrete_frozen
  a: 0
  args: !!python/tuple []
  b: .inf
  dist: &id004 !!python/object:scipy.stats._discrete_distns.poisson_gen
    __doc__: "A Poisson discrete random variable.\n\n    As an instance of the `rv_discrete`\
      \ class, `poisson` object inherits from it\n    a collection of generic methods\
      \ (see below for the full list),\n    and completes them with details specific\
      \ for this particular distribution.\n    \n    Methods\n    -------\n    rvs(mu,\
      \ loc=0, size=1, random_state=None)\n        Random variates.\n    pmf(k, mu,\
      \ loc=0)\n        Probability mass function.\n    logpmf(k, mu, loc=0)\n   \
      \     Log of the probability mass function.\n    cdf(k, mu, loc=0)\n       \
      \ Cumulative distribution function.\n    logcdf(k, mu, loc=0)\n        Log of\
      \ the cumulative distribution function.\n    sf(k, mu, loc=0)\n        Survival\
      \ function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n\
      \    logsf(k, mu, loc=0)\n        Log of the survival function.\n    ppf(q,\
      \ mu, loc=0)\n        Percent point function (inverse of ``cdf`` --- percentiles).\n\
      \    isf(q, mu, loc=0)\n        Inverse survival function (inverse of ``sf``).\n\
      \    stats(mu, loc=0, moments='mv')\n        Mean('m'), variance('v'), skew('s'),\
      \ and/or kurtosis('k').\n    entropy(mu, loc=0)\n        (Differential) entropy\
      \ of the RV.\n    expect(func, args=(mu,), loc=0, lb=None, ub=None, conditional=False)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(mu, loc=0)\n        Median of the distribution.\n\
      \    mean(mu, loc=0)\n        Mean of the distribution.\n    var(mu, loc=0)\n\
      \        Variance of the distribution.\n    std(mu, loc=0)\n        Standard\
      \ deviation of the distribution.\n    interval(confidence, mu, loc=0)\n    \
      \    Confidence interval with equal areas around the median.\n\n    Notes\n\
      \    -----\n    The probability mass function for `poisson` is:\n\n    .. math::\n\
      \n        f(k) = \\exp(-\\mu) \\frac{\\mu^k}{k!}\n\n    for :math:`k \\ge 0`.\n\
      \n    `poisson` takes :math:`\\mu \\geq 0` as shape parameter.\n    When :math:`\\\
      mu = 0`, the ``pmf`` method\n    returns ``1.0`` at quantile :math:`k = 0`.\n\
      \n    The probability mass function above is defined in the \"standardized\"\
      \ form.\n    To shift distribution use the ``loc`` parameter.\n    Specifically,\
      \ ``poisson.pmf(k, mu, loc)`` is identically\n    equivalent to ``poisson.pmf(k\
      \ - loc, mu)``.\n\n    Examples\n    --------\n    >>> import numpy as np\n\
      \    >>> from scipy.stats import poisson\n    >>> import matplotlib.pyplot as\
      \ plt\n    >>> fig, ax = plt.subplots(1, 1)\n    \n    Calculate the first four\
      \ moments:\n    \n    >>> mu = 0.6\n    >>> mean, var, skew, kurt = poisson.stats(mu,\
      \ moments='mvsk')\n    \n    Display the probability mass function (``pmf``):\n\
      \    \n    >>> x = np.arange(poisson.ppf(0.01, mu),\n    ...               poisson.ppf(0.99,\
      \ mu))\n    >>> ax.plot(x, poisson.pmf(x, mu), 'bo', ms=8, label='poisson pmf')\n\
      \    >>> ax.vlines(x, 0, poisson.pmf(x, mu), colors='b', lw=5, alpha=0.5)\n\
      \    \n    Alternatively, the distribution object can be called (as a function)\n\
      \    to fix the shape and location. This returns a \"frozen\" RV object holding\n\
      \    the given parameters fixed.\n    \n    Freeze the distribution and display\
      \ the frozen ``pmf``:\n    \n    >>> rv = poisson(mu)\n    >>> ax.vlines(x,\
      \ 0, rv.pmf(x), colors='k', linestyles='-', lw=1,\n    ...         label='frozen\
      \ pmf')\n    >>> ax.legend(loc='best', frameon=False)\n    >>> plt.show()\n\
      \    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> prob = poisson.cdf(x,\
      \ mu)\n    >>> np.allclose(x, poisson.ppf(prob, mu))\n    True\n    \n    Generate\
      \ random numbers:\n    \n    >>> r = poisson.rvs(mu, size=1000)\n\n    "
    _ctor_param:
      a: 0
      b: .inf
      badvalue: .nan
      inc: 1
      longname: A Poisson
      moment_tol: 1.0e-08
      name: poisson
      seed: null
      shapes: mu
      values: null
    _parse_arg_template: "\ndef _parse_args(self, mu,  loc=0):\n    return (mu, ),\
      \ loc, 1\n\ndef _parse_args_rvs(self, mu,  loc=0, size=None):\n    return self._argcheck_rvs(mu,\
      \  loc, 1, size=size)\n\ndef _parse_args_stats(self, mu,  loc=0, moments='mv'):\n\
      \    return (mu, ), loc, 1, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0
    b: .inf
    badvalue: .nan
    inc: 1
    moment_tol: 1.0e-08
    name: poisson
    numargs: 1
    shapes: mu
    vecentropy: !!python/object:numpy.vectorize
      __doc__: null
      __name__: _entropy
      _doc: null
      _in_and_out_core_dims: null
      _ufunc: {}
      cache: false
      excluded: !!set {}
      otypes: null
      pyfunc: !!python/object/apply:builtins.getattr
      - *id004
      - _entropy
      signature: null
  kwds:
    mu: 3
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.expon_gen
    __doc__: "An exponential continuous random variable.\n\n    As an instance of\
      \ the `rv_continuous` class, `expon` object inherits from it\n    a collection\
      \ of generic methods (see below for the full list),\n    and completes them\
      \ with details specific for this particular distribution.\n    \n    Methods\n\
      \    -------\n    rvs(loc=0, scale=1, size=1, random_state=None)\n        Random\
      \ variates.\n    pdf(x, loc=0, scale=1)\n        Probability density function.\n\
      \    logpdf(x, loc=0, scale=1)\n        Log of the probability density function.\n\
      \    cdf(x, loc=0, scale=1)\n        Cumulative distribution function.\n   \
      \ logcdf(x, loc=0, scale=1)\n        Log of the cumulative distribution function.\n\
      \    sf(x, loc=0, scale=1)\n        Survival function  (also defined as ``1\
      \ - cdf``, but `sf` is sometimes more accurate).\n    logsf(x, loc=0, scale=1)\n\
      \        Log of the survival function.\n    ppf(q, loc=0, scale=1)\n       \
      \ Percent point function (inverse of ``cdf`` --- percentiles).\n    isf(q, loc=0,\
      \ scale=1)\n        Inverse survival function (inverse of ``sf``).\n    moment(order,\
      \ loc=0, scale=1)\n        Non-central moment of the specified order.\n    stats(loc=0,\
      \ scale=1, moments='mv')\n        Mean('m'), variance('v'), skew('s'), and/or\
      \ kurtosis('k').\n    entropy(loc=0, scale=1)\n        (Differential) entropy\
      \ of the RV.\n    fit(data)\n        Parameter estimates for generic data.\n\
      \        See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n  \
      \      Expected value of a function (of one argument) with respect to the distribution.\n\
      \    median(loc=0, scale=1)\n        Median of the distribution.\n    mean(loc=0,\
      \ scale=1)\n        Mean of the distribution.\n    var(loc=0, scale=1)\n   \
      \     Variance of the distribution.\n    std(loc=0, scale=1)\n        Standard\
      \ deviation of the distribution.\n    interval(confidence, loc=0, scale=1)\n\
      \        Confidence interval with equal areas around the median.\n\n    Notes\n\
      \    -----\n    The probability density function for `expon` is:\n\n    .. math::\n\
      \n        f(x) = \\exp(-x)\n\n    for :math:`x \\ge 0`.\n\n    The probability\
      \ density above is defined in the \"standardized\" form. To shift\n    and/or\
      \ scale the distribution use the ``loc`` and ``scale`` parameters.\n    Specifically,\
      \ ``expon.pdf(x, loc, scale)`` is identically\n    equivalent to ``expon.pdf(y)\
      \ / scale`` with\n    ``y = (x - loc) / scale``. Note that shifting the location\
      \ of a distribution\n    does not make it a \"noncentral\" distribution; noncentral\
      \ generalizations of\n    some distributions are available in separate classes.\n\
      \n    A common parameterization for `expon` is in terms of the rate parameter\n\
      \    ``lambda``, such that ``pdf = lambda * exp(-lambda * x)``. This\n    parameterization\
      \ corresponds to using ``scale = 1 / lambda``.\n\n    The exponential distribution\
      \ is a special case of the gamma\n    distributions, with gamma shape parameter\
      \ ``a = 1``.\n\n    Examples\n    --------\n    >>> import numpy as np\n   \
      \ >>> from scipy.stats import expon\n    >>> import matplotlib.pyplot as plt\n\
      \    >>> fig, ax = plt.subplots(1, 1)\n    \n    Calculate the first four moments:\n\
      \    \n    \n    >>> mean, var, skew, kurt = expon.stats(moments='mvsk')\n \
      \   \n    Display the probability density function (``pdf``):\n    \n    >>>\
      \ x = np.linspace(expon.ppf(0.01),\n    ...                 expon.ppf(0.99),\
      \ 100)\n    >>> ax.plot(x, expon.pdf(x),\n    ...        'r-', lw=5, alpha=0.6,\
      \ label='expon pdf')\n    \n    Alternatively, the distribution object can be\
      \ called (as a function)\n    to fix the shape, location and scale parameters.\
      \ This returns a \"frozen\"\n    RV object holding the given parameters fixed.\n\
      \    \n    Freeze the distribution and display the frozen ``pdf``:\n    \n \
      \   >>> rv = expon()\n    >>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen\
      \ pdf')\n    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> vals\
      \ = expon.ppf([0.001, 0.5, 0.999])\n    >>> np.allclose([0.001, 0.5, 0.999],\
      \ expon.cdf(vals))\n    True\n    \n    Generate random numbers:\n    \n   \
      \ >>> r = expon.rvs(size=1000)\n    \n    And compare the histogram:\n    \n\
      \    >>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)\n\
      \    >>> ax.set_xlim([x[0], x[-1]])\n    >>> ax.legend(loc='best', frameon=False)\n\
      \    >>> plt.show()\n    \n\n    "
    _ctor_param:
      a: 0.0
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: expon
      seed: null
      shapes: null
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self,  loc=0, scale=1):\n    return (),\
      \ loc, scale\n\ndef _parse_args_rvs(self,  loc=0, scale=1, size=None):\n   \
      \ return self._argcheck_rvs( loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \  loc=0, scale=1, moments='mv'):\n    return (), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0.0
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: expon
    numargs: 0
    shapes: null
    xtol: 1.0e-14
  kwds:
    scale: 1
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.gamma_gen
    __doc__: "A gamma continuous random variable.\n\n    As an instance of the `rv_continuous`\
      \ class, `gamma` object inherits from it\n    a collection of generic methods\
      \ (see below for the full list),\n    and completes them with details specific\
      \ for this particular distribution.\n    \n    Methods\n    -------\n    rvs(a,\
      \ loc=0, scale=1, size=1, random_state=None)\n        Random variates.\n   \
      \ pdf(x, a, loc=0, scale=1)\n        Probability density function.\n    logpdf(x,\
      \ a, loc=0, scale=1)\n        Log of the probability density function.\n   \
      \ cdf(x, a, loc=0, scale=1)\n        Cumulative distribution function.\n   \
      \ logcdf(x, a, loc=0, scale=1)\n        Log of the cumulative distribution function.\n\
      \    sf(x, a, loc=0, scale=1)\n        Survival function  (also defined as ``1\
      \ - cdf``, but `sf` is sometimes more accurate).\n    logsf(x, a, loc=0, scale=1)\n\
      \        Log of the survival function.\n    ppf(q, a, loc=0, scale=1)\n    \
      \    Percent point function (inverse of ``cdf`` --- percentiles).\n    isf(q,\
      \ a, loc=0, scale=1)\n        Inverse survival function (inverse of ``sf``).\n\
      \    moment(order, a, loc=0, scale=1)\n        Non-central moment of the specified\
      \ order.\n    stats(a, loc=0, scale=1, moments='mv')\n        Mean('m'), variance('v'),\
      \ skew('s'), and/or kurtosis('k').\n    entropy(a, loc=0, scale=1)\n       \
      \ (Differential) entropy of the RV.\n    fit(data)\n        Parameter estimates\
      \ for generic data.\n        See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(a,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(a, loc=0, scale=1)\n        Median of the distribution.\n\
      \    mean(a, loc=0, scale=1)\n        Mean of the distribution.\n    var(a,\
      \ loc=0, scale=1)\n        Variance of the distribution.\n    std(a, loc=0,\
      \ scale=1)\n        Standard deviation of the distribution.\n    interval(confidence,\
      \ a, loc=0, scale=1)\n        Confidence interval with equal areas around the\
      \ median.\n\n    See Also\n    --------\n    erlang, expon\n\n    Notes\n  \
      \  -----\n    The probability density function for `gamma` is:\n\n    .. math::\n\
      \n        f(x, a) = \\frac{x^{a-1} e^{-x}}{\\Gamma(a)}\n\n    for :math:`x \\\
      ge 0`, :math:`a > 0`. Here :math:`\\Gamma(a)` refers to the\n    gamma function.\n\
      \n    `gamma` takes ``a`` as a shape parameter for :math:`a`.\n\n    When :math:`a`\
      \ is an integer, `gamma` reduces to the Erlang\n    distribution, and when :math:`a=1`\
      \ to the exponential distribution.\n\n    Gamma distributions are sometimes\
      \ parameterized with two variables,\n    with a probability density function\
      \ of:\n\n    .. math::\n\n        f(x, \\alpha, \\beta) =\n        \\frac{\\\
      beta^\\alpha x^{\\alpha - 1} e^{-\\beta x }}{\\Gamma(\\alpha)}\n\n    Note that\
      \ this parameterization is equivalent to the above, with\n    ``scale = 1 /\
      \ beta``.\n\n    The probability density above is defined in the \"standardized\"\
      \ form. To shift\n    and/or scale the distribution use the ``loc`` and ``scale``\
      \ parameters.\n    Specifically, ``gamma.pdf(x, a, loc, scale)`` is identically\n\
      \    equivalent to ``gamma.pdf(y, a) / scale`` with\n    ``y = (x - loc) / scale``.\
      \ Note that shifting the location of a distribution\n    does not make it a\
      \ \"noncentral\" distribution; noncentral generalizations of\n    some distributions\
      \ are available in separate classes.\n\n    Examples\n    --------\n    >>>\
      \ import numpy as np\n    >>> from scipy.stats import gamma\n    >>> import\
      \ matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(1, 1)\n    \n   \
      \ Calculate the first four moments:\n    \n    >>> a = 1.99\n    >>> mean, var,\
      \ skew, kurt = gamma.stats(a, moments='mvsk')\n    \n    Display the probability\
      \ density function (``pdf``):\n    \n    >>> x = np.linspace(gamma.ppf(0.01,\
      \ a),\n    ...                 gamma.ppf(0.99, a), 100)\n    >>> ax.plot(x,\
      \ gamma.pdf(x, a),\n    ...        'r-', lw=5, alpha=0.6, label='gamma pdf')\n\
      \    \n    Alternatively, the distribution object can be called (as a function)\n\
      \    to fix the shape, location and scale parameters. This returns a \"frozen\"\
      \n    RV object holding the given parameters fixed.\n    \n    Freeze the distribution\
      \ and display the frozen ``pdf``:\n    \n    >>> rv = gamma(a)\n    >>> ax.plot(x,\
      \ rv.pdf(x), 'k-', lw=2, label='frozen pdf')\n    \n    Check accuracy of ``cdf``\
      \ and ``ppf``:\n    \n    >>> vals = gamma.ppf([0.001, 0.5, 0.999], a)\n   \
      \ >>> np.allclose([0.001, 0.5, 0.999], gamma.cdf(vals, a))\n    True\n    \n\
      \    Generate random numbers:\n    \n    >>> r = gamma.rvs(a, size=1000)\n \
      \   \n    And compare the histogram:\n    \n    >>> ax.hist(r, density=True,\
      \ bins='auto', histtype='stepfilled', alpha=0.2)\n    >>> ax.set_xlim([x[0],\
      \ x[-1]])\n    >>> ax.legend(loc='best', frameon=False)\n    >>> plt.show()\n\
      \    \n\n    "
    _ctor_param:
      a: 0.0
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: gamma
      seed: null
      shapes: a
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self, a,  loc=0, scale=1):\n    return\
      \ (a, ), loc, scale\n\ndef _parse_args_rvs(self, a,  loc=0, scale=1, size=None):\n\
      \    return self._argcheck_rvs(a,  loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \ a,  loc=0, scale=1, moments='mv'):\n    return (a, ), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0.0
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: gamma
    numargs: 1
    shapes: a
    xtol: 1.0e-14
  kwds:
    a: 2
    scale: 1
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: 1.0
  dist: !!python/object:scipy.stats._continuous_distns.beta_gen
    __doc__: "A beta continuous random variable.\n\n    As an instance of the `rv_continuous`\
      \ class, `beta` object inherits from it\n    a collection of generic methods\
      \ (see below for the full list),\n    and completes them with details specific\
      \ for this particular distribution.\n    \n    Methods\n    -------\n    rvs(a,\
      \ b, loc=0, scale=1, size=1, random_state=None)\n        Random variates.\n\
      \    pdf(x, a, b, loc=0, scale=1)\n        Probability density function.\n \
      \   logpdf(x, a, b, loc=0, scale=1)\n        Log of the probability density\
      \ function.\n    cdf(x, a, b, loc=0, scale=1)\n        Cumulative distribution\
      \ function.\n    logcdf(x, a, b, loc=0, scale=1)\n        Log of the cumulative\
      \ distribution function.\n    sf(x, a, b, loc=0, scale=1)\n        Survival\
      \ function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n\
      \    logsf(x, a, b, loc=0, scale=1)\n        Log of the survival function.\n\
      \    ppf(q, a, b, loc=0, scale=1)\n        Percent point function (inverse of\
      \ ``cdf`` --- percentiles).\n    isf(q, a, b, loc=0, scale=1)\n        Inverse\
      \ survival function (inverse of ``sf``).\n    moment(order, a, b, loc=0, scale=1)\n\
      \        Non-central moment of the specified order.\n    stats(a, b, loc=0,\
      \ scale=1, moments='mv')\n        Mean('m'), variance('v'), skew('s'), and/or\
      \ kurtosis('k').\n    entropy(a, b, loc=0, scale=1)\n        (Differential)\
      \ entropy of the RV.\n    fit(data)\n        Parameter estimates for generic\
      \ data.\n        See `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(a, b), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(a, b, loc=0, scale=1)\n        Median of the distribution.\n\
      \    mean(a, b, loc=0, scale=1)\n        Mean of the distribution.\n    var(a,\
      \ b, loc=0, scale=1)\n        Variance of the distribution.\n    std(a, b, loc=0,\
      \ scale=1)\n        Standard deviation of the distribution.\n    interval(confidence,\
      \ a, b, loc=0, scale=1)\n        Confidence interval with equal areas around\
      \ the median.\n\n    Notes\n    -----\n    The probability density function\
      \ for `beta` is:\n\n    .. math::\n\n        f(x, a, b) = \\frac{\\Gamma(a+b)\
      \ x^{a-1} (1-x)^{b-1}}\n                          {\\Gamma(a) \\Gamma(b)}\n\n\
      \    for :math:`0 <= x <= 1`, :math:`a > 0`, :math:`b > 0`, where\n    :math:`\\\
      Gamma` is the gamma function (`scipy.special.gamma`).\n\n    `beta` takes :math:`a`\
      \ and :math:`b` as shape parameters.\n\n    The probability density above is\
      \ defined in the \"standardized\" form. To shift\n    and/or scale the distribution\
      \ use the ``loc`` and ``scale`` parameters.\n    Specifically, ``beta.pdf(x,\
      \ a, b, loc, scale)`` is identically\n    equivalent to ``beta.pdf(y, a, b)\
      \ / scale`` with\n    ``y = (x - loc) / scale``. Note that shifting the location\
      \ of a distribution\n    does not make it a \"noncentral\" distribution; noncentral\
      \ generalizations of\n    some distributions are available in separate classes.\n\
      \n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.stats\
      \ import beta\n    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(1,\
      \ 1)\n    \n    Calculate the first four moments:\n    \n    >>> a, b = 2.31,\
      \ 0.627\n    >>> mean, var, skew, kurt = beta.stats(a, b, moments='mvsk')\n\
      \    \n    Display the probability density function (``pdf``):\n    \n    >>>\
      \ x = np.linspace(beta.ppf(0.01, a, b),\n    ...                 beta.ppf(0.99,\
      \ a, b), 100)\n    >>> ax.plot(x, beta.pdf(x, a, b),\n    ...        'r-', lw=5,\
      \ alpha=0.6, label='beta pdf')\n    \n    Alternatively, the distribution object\
      \ can be called (as a function)\n    to fix the shape, location and scale parameters.\
      \ This returns a \"frozen\"\n    RV object holding the given parameters fixed.\n\
      \    \n    Freeze the distribution and display the frozen ``pdf``:\n    \n \
      \   >>> rv = beta(a, b)\n    >>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen\
      \ pdf')\n    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> vals\
      \ = beta.ppf([0.001, 0.5, 0.999], a, b)\n    >>> np.allclose([0.001, 0.5, 0.999],\
      \ beta.cdf(vals, a, b))\n    True\n    \n    Generate random numbers:\n    \n\
      \    >>> r = beta.rvs(a, b, size=1000)\n    \n    And compare the histogram:\n\
      \    \n    >>> ax.hist(r, density=True, bins='auto', histtype='stepfilled',\
      \ alpha=0.2)\n    >>> ax.set_xlim([x[0], x[-1]])\n    >>> ax.legend(loc='best',\
      \ frameon=False)\n    >>> plt.show()\n    \n\n    "
    _ctor_param:
      a: 0.0
      b: 1.0
      badvalue: .nan
      longname: null
      momtype: 1
      name: beta
      seed: null
      shapes: a, b
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self, a, b,  loc=0, scale=1):\n    return\
      \ (a, b, ), loc, scale\n\ndef _parse_args_rvs(self, a, b,  loc=0, scale=1, size=None):\n\
      \    return self._argcheck_rvs(a, b,  loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \ a, b,  loc=0, scale=1, moments='mv'):\n    return (a, b, ), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0.0
    b: 1.0
    badvalue: .nan
    moment_type: 1
    name: beta
    numargs: 2
    shapes: a, b
    xtol: 1.0e-14
  kwds:
    a: 2
    b: 5
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.chi2_gen
    __doc__: "A chi-squared continuous random variable.\n\n    For the noncentral\
      \ chi-square distribution, see `ncx2`.\n\n    As an instance of the `rv_continuous`\
      \ class, `chi2` object inherits from it\n    a collection of generic methods\
      \ (see below for the full list),\n    and completes them with details specific\
      \ for this particular distribution.\n    \n    Methods\n    -------\n    rvs(df,\
      \ loc=0, scale=1, size=1, random_state=None)\n        Random variates.\n   \
      \ pdf(x, df, loc=0, scale=1)\n        Probability density function.\n    logpdf(x,\
      \ df, loc=0, scale=1)\n        Log of the probability density function.\n  \
      \  cdf(x, df, loc=0, scale=1)\n        Cumulative distribution function.\n \
      \   logcdf(x, df, loc=0, scale=1)\n        Log of the cumulative distribution\
      \ function.\n    sf(x, df, loc=0, scale=1)\n        Survival function  (also\
      \ defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n    logsf(x,\
      \ df, loc=0, scale=1)\n        Log of the survival function.\n    ppf(q, df,\
      \ loc=0, scale=1)\n        Percent point function (inverse of ``cdf`` --- percentiles).\n\
      \    isf(q, df, loc=0, scale=1)\n        Inverse survival function (inverse\
      \ of ``sf``).\n    moment(order, df, loc=0, scale=1)\n        Non-central moment\
      \ of the specified order.\n    stats(df, loc=0, scale=1, moments='mv')\n   \
      \     Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').\n    entropy(df,\
      \ loc=0, scale=1)\n        (Differential) entropy of the RV.\n    fit(data)\n\
      \        Parameter estimates for generic data.\n        See `scipy.stats.rv_continuous.fit\
      \ <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(df,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(df, loc=0, scale=1)\n        Median of the distribution.\n\
      \    mean(df, loc=0, scale=1)\n        Mean of the distribution.\n    var(df,\
      \ loc=0, scale=1)\n        Variance of the distribution.\n    std(df, loc=0,\
      \ scale=1)\n        Standard deviation of the distribution.\n    interval(confidence,\
      \ df, loc=0, scale=1)\n        Confidence interval with equal areas around the\
      \ median.\n\n    See Also\n    --------\n    ncx2\n\n    Notes\n    -----\n\
      \    The probability density function for `chi2` is:\n\n    .. math::\n\n  \
      \      f(x, k) = \\frac{1}{2^{k/2} \\Gamma \\left( k/2 \\right)}\n         \
      \          x^{k/2-1} \\exp \\left( -x/2 \\right)\n\n    for :math:`x > 0`  and\
      \ :math:`k > 0` (degrees of freedom, denoted ``df``\n    in the implementation).\n\
      \n    `chi2` takes ``df`` as a shape parameter.\n\n    The chi-squared distribution\
      \ is a special case of the gamma\n    distribution, with gamma parameters ``a\
      \ = df/2``, ``loc = 0`` and\n    ``scale = 2``.\n\n    The probability density\
      \ above is defined in the \"standardized\" form. To shift\n    and/or scale\
      \ the distribution use the ``loc`` and ``scale`` parameters.\n    Specifically,\
      \ ``chi2.pdf(x, df, loc, scale)`` is identically\n    equivalent to ``chi2.pdf(y,\
      \ df) / scale`` with\n    ``y = (x - loc) / scale``. Note that shifting the\
      \ location of a distribution\n    does not make it a \"noncentral\" distribution;\
      \ noncentral generalizations of\n    some distributions are available in separate\
      \ classes.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>>\
      \ from scipy.stats import chi2\n    >>> import matplotlib.pyplot as plt\n  \
      \  >>> fig, ax = plt.subplots(1, 1)\n    \n    Calculate the first four moments:\n\
      \    \n    >>> df = 55\n    >>> mean, var, skew, kurt = chi2.stats(df, moments='mvsk')\n\
      \    \n    Display the probability density function (``pdf``):\n    \n    >>>\
      \ x = np.linspace(chi2.ppf(0.01, df),\n    ...                 chi2.ppf(0.99,\
      \ df), 100)\n    >>> ax.plot(x, chi2.pdf(x, df),\n    ...        'r-', lw=5,\
      \ alpha=0.6, label='chi2 pdf')\n    \n    Alternatively, the distribution object\
      \ can be called (as a function)\n    to fix the shape, location and scale parameters.\
      \ This returns a \"frozen\"\n    RV object holding the given parameters fixed.\n\
      \    \n    Freeze the distribution and display the frozen ``pdf``:\n    \n \
      \   >>> rv = chi2(df)\n    >>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen\
      \ pdf')\n    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> vals\
      \ = chi2.ppf([0.001, 0.5, 0.999], df)\n    >>> np.allclose([0.001, 0.5, 0.999],\
      \ chi2.cdf(vals, df))\n    True\n    \n    Generate random numbers:\n    \n\
      \    >>> r = chi2.rvs(df, size=1000)\n    \n    And compare the histogram:\n\
      \    \n    >>> ax.hist(r, density=True, bins='auto', histtype='stepfilled',\
      \ alpha=0.2)\n    >>> ax.set_xlim([x[0], x[-1]])\n    >>> ax.legend(loc='best',\
      \ frameon=False)\n    >>> plt.show()\n    \n\n    "
    _ctor_param:
      a: 0.0
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: chi2
      seed: null
      shapes: df
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self, df,  loc=0, scale=1):\n    return\
      \ (df, ), loc, scale\n\ndef _parse_args_rvs(self, df,  loc=0, scale=1, size=None):\n\
      \    return self._argcheck_rvs(df,  loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \ df,  loc=0, scale=1, moments='mv'):\n    return (df, ), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0.0
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: chi2
    numargs: 1
    shapes: df
    xtol: 1.0e-14
  kwds:
    df: 2
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: -.inf
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.t_gen
    __doc__: "A Student's t continuous random variable.\n\n    For the noncentral\
      \ t distribution, see `nct`.\n\n    As an instance of the `rv_continuous` class,\
      \ `t` object inherits from it\n    a collection of generic methods (see below\
      \ for the full list),\n    and completes them with details specific for this\
      \ particular distribution.\n    \n    Methods\n    -------\n    rvs(df, loc=0,\
      \ scale=1, size=1, random_state=None)\n        Random variates.\n    pdf(x,\
      \ df, loc=0, scale=1)\n        Probability density function.\n    logpdf(x,\
      \ df, loc=0, scale=1)\n        Log of the probability density function.\n  \
      \  cdf(x, df, loc=0, scale=1)\n        Cumulative distribution function.\n \
      \   logcdf(x, df, loc=0, scale=1)\n        Log of the cumulative distribution\
      \ function.\n    sf(x, df, loc=0, scale=1)\n        Survival function  (also\
      \ defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n    logsf(x,\
      \ df, loc=0, scale=1)\n        Log of the survival function.\n    ppf(q, df,\
      \ loc=0, scale=1)\n        Percent point function (inverse of ``cdf`` --- percentiles).\n\
      \    isf(q, df, loc=0, scale=1)\n        Inverse survival function (inverse\
      \ of ``sf``).\n    moment(order, df, loc=0, scale=1)\n        Non-central moment\
      \ of the specified order.\n    stats(df, loc=0, scale=1, moments='mv')\n   \
      \     Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').\n    entropy(df,\
      \ loc=0, scale=1)\n        (Differential) entropy of the RV.\n    fit(data)\n\
      \        Parameter estimates for generic data.\n        See `scipy.stats.rv_continuous.fit\
      \ <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(df,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(df, loc=0, scale=1)\n        Median of the distribution.\n\
      \    mean(df, loc=0, scale=1)\n        Mean of the distribution.\n    var(df,\
      \ loc=0, scale=1)\n        Variance of the distribution.\n    std(df, loc=0,\
      \ scale=1)\n        Standard deviation of the distribution.\n    interval(confidence,\
      \ df, loc=0, scale=1)\n        Confidence interval with equal areas around the\
      \ median.\n\n    See Also\n    --------\n    nct\n\n    Notes\n    -----\n \
      \   The probability density function for `t` is:\n\n    .. math::\n\n      \
      \  f(x, \\nu) = \\frac{\\Gamma((\\nu+1)/2)}\n                        {\\sqrt{\\\
      pi \\nu} \\Gamma(\\nu/2)}\n                    (1+x^2/\\nu)^{-(\\nu+1)/2}\n\n\
      \    where :math:`x` is a real number and the degrees of freedom parameter\n\
      \    :math:`\\nu` (denoted ``df`` in the implementation) satisfies\n    :math:`\\\
      nu > 0`. :math:`\\Gamma` is the gamma function\n    (`scipy.special.gamma`).\n\
      \n    The probability density above is defined in the \"standardized\" form.\
      \ To shift\n    and/or scale the distribution use the ``loc`` and ``scale``\
      \ parameters.\n    Specifically, ``t.pdf(x, df, loc, scale)`` is identically\n\
      \    equivalent to ``t.pdf(y, df) / scale`` with\n    ``y = (x - loc) / scale``.\
      \ Note that shifting the location of a distribution\n    does not make it a\
      \ \"noncentral\" distribution; noncentral generalizations of\n    some distributions\
      \ are available in separate classes.\n\n    Examples\n    --------\n    >>>\
      \ import numpy as np\n    >>> from scipy.stats import t\n    >>> import matplotlib.pyplot\
      \ as plt\n    >>> fig, ax = plt.subplots(1, 1)\n    \n    Calculate the first\
      \ four moments:\n    \n    >>> df = 2.74\n    >>> mean, var, skew, kurt = t.stats(df,\
      \ moments='mvsk')\n    \n    Display the probability density function (``pdf``):\n\
      \    \n    >>> x = np.linspace(t.ppf(0.01, df),\n    ...                 t.ppf(0.99,\
      \ df), 100)\n    >>> ax.plot(x, t.pdf(x, df),\n    ...        'r-', lw=5, alpha=0.6,\
      \ label='t pdf')\n    \n    Alternatively, the distribution object can be called\
      \ (as a function)\n    to fix the shape, location and scale parameters. This\
      \ returns a \"frozen\"\n    RV object holding the given parameters fixed.\n\
      \    \n    Freeze the distribution and display the frozen ``pdf``:\n    \n \
      \   >>> rv = t(df)\n    >>> ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen\
      \ pdf')\n    \n    Check accuracy of ``cdf`` and ``ppf``:\n    \n    >>> vals\
      \ = t.ppf([0.001, 0.5, 0.999], df)\n    >>> np.allclose([0.001, 0.5, 0.999],\
      \ t.cdf(vals, df))\n    True\n    \n    Generate random numbers:\n    \n   \
      \ >>> r = t.rvs(df, size=1000)\n    \n    And compare the histogram:\n    \n\
      \    >>> ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2)\n\
      \    >>> ax.set_xlim([x[0], x[-1]])\n    >>> ax.legend(loc='best', frameon=False)\n\
      \    >>> plt.show()\n    \n\n    "
    _ctor_param:
      a: -.inf
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: t
      seed: null
      shapes: df
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self, df,  loc=0, scale=1):\n    return\
      \ (df, ), loc, scale\n\ndef _parse_args_rvs(self, df,  loc=0, scale=1, size=None):\n\
      \    return self._argcheck_rvs(df,  loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \ df,  loc=0, scale=1, moments='mv'):\n    return (df, ), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: -.inf
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: t
    numargs: 1
    shapes: df
    xtol: 1.0e-14
  kwds:
    df: 10
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.lognorm_gen
    __doc__: "A lognormal continuous random variable.\n\n    As an instance of the\
      \ `rv_continuous` class, `lognorm` object inherits from it\n    a collection\
      \ of generic methods (see below for the full list),\n    and completes them\
      \ with details specific for this particular distribution.\n    \n    Methods\n\
      \    -------\n    rvs(s, loc=0, scale=1, size=1, random_state=None)\n      \
      \  Random variates.\n    pdf(x, s, loc=0, scale=1)\n        Probability density\
      \ function.\n    logpdf(x, s, loc=0, scale=1)\n        Log of the probability\
      \ density function.\n    cdf(x, s, loc=0, scale=1)\n        Cumulative distribution\
      \ function.\n    logcdf(x, s, loc=0, scale=1)\n        Log of the cumulative\
      \ distribution function.\n    sf(x, s, loc=0, scale=1)\n        Survival function\
      \  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n   \
      \ logsf(x, s, loc=0, scale=1)\n        Log of the survival function.\n    ppf(q,\
      \ s, loc=0, scale=1)\n        Percent point function (inverse of ``cdf`` ---\
      \ percentiles).\n    isf(q, s, loc=0, scale=1)\n        Inverse survival function\
      \ (inverse of ``sf``).\n    moment(order, s, loc=0, scale=1)\n        Non-central\
      \ moment of the specified order.\n    stats(s, loc=0, scale=1, moments='mv')\n\
      \        Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').\n    entropy(s,\
      \ loc=0, scale=1)\n        (Differential) entropy of the RV.\n    fit(data)\n\
      \        Parameter estimates for generic data.\n        See `scipy.stats.rv_continuous.fit\
      \ <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(s,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(s, loc=0, scale=1)\n        Median of the distribution.\n\
      \    mean(s, loc=0, scale=1)\n        Mean of the distribution.\n    var(s,\
      \ loc=0, scale=1)\n        Variance of the distribution.\n    std(s, loc=0,\
      \ scale=1)\n        Standard deviation of the distribution.\n    interval(confidence,\
      \ s, loc=0, scale=1)\n        Confidence interval with equal areas around the\
      \ median.\n\n    Notes\n    -----\n    The probability density function for\
      \ `lognorm` is:\n\n    .. math::\n\n        f(x, s) = \\frac{1}{s x \\sqrt{2\\\
      pi}}\n                  \\exp\\left(-\\frac{\\log^2(x)}{2s^2}\\right)\n\n  \
      \  for :math:`x > 0`, :math:`s > 0`.\n\n    `lognorm` takes ``s`` as a shape\
      \ parameter for :math:`s`.\n\n    The probability density above is defined in\
      \ the \"standardized\" form. To shift\n    and/or scale the distribution use\
      \ the ``loc`` and ``scale`` parameters.\n    Specifically, ``lognorm.pdf(x,\
      \ s, loc, scale)`` is identically\n    equivalent to ``lognorm.pdf(y, s) / scale``\
      \ with\n    ``y = (x - loc) / scale``. Note that shifting the location of a\
      \ distribution\n    does not make it a \"noncentral\" distribution; noncentral\
      \ generalizations of\n    some distributions are available in separate classes.\n\
      \n    Suppose a normally distributed random variable ``X`` has  mean ``mu``\
      \ and\n    standard deviation ``sigma``. Then ``Y = exp(X)`` is lognormally\n\
      \    distributed with ``s = sigma`` and ``scale = exp(mu)``.\n\n    Examples\n\
      \    --------\n    >>> import numpy as np\n    >>> from scipy.stats import lognorm\n\
      \    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(1,\
      \ 1)\n    \n    Calculate the first four moments:\n    \n    >>> s = 0.954\n\
      \    >>> mean, var, skew, kurt = lognorm.stats(s, moments='mvsk')\n    \n  \
      \  Display the probability density function (``pdf``):\n    \n    >>> x = np.linspace(lognorm.ppf(0.01,\
      \ s),\n    ...                 lognorm.ppf(0.99, s), 100)\n    >>> ax.plot(x,\
      \ lognorm.pdf(x, s),\n    ...        'r-', lw=5, alpha=0.6, label='lognorm pdf')\n\
      \    \n    Alternatively, the distribution object can be called (as a function)\n\
      \    to fix the shape, location and scale parameters. This returns a \"frozen\"\
      \n    RV object holding the given parameters fixed.\n    \n    Freeze the distribution\
      \ and display the frozen ``pdf``:\n    \n    >>> rv = lognorm(s)\n    >>> ax.plot(x,\
      \ rv.pdf(x), 'k-', lw=2, label='frozen pdf')\n    \n    Check accuracy of ``cdf``\
      \ and ``ppf``:\n    \n    >>> vals = lognorm.ppf([0.001, 0.5, 0.999], s)\n \
      \   >>> np.allclose([0.001, 0.5, 0.999], lognorm.cdf(vals, s))\n    True\n \
      \   \n    Generate random numbers:\n    \n    >>> r = lognorm.rvs(s, size=1000)\n\
      \    \n    And compare the histogram:\n    \n    >>> ax.hist(r, density=True,\
      \ bins='auto', histtype='stepfilled', alpha=0.2)\n    >>> ax.set_xlim([x[0],\
      \ x[-1]])\n    >>> ax.legend(loc='best', frameon=False)\n    >>> plt.show()\n\
      \    \n\n    The logarithm of a log-normally distributed random variable is\n\
      \    normally distributed:\n\n    >>> import numpy as np\n    >>> import matplotlib.pyplot\
      \ as plt\n    >>> from scipy import stats\n    >>> fig, ax = plt.subplots(1,\
      \ 1)\n    >>> mu, sigma = 2, 0.5\n    >>> X = stats.norm(loc=mu, scale=sigma)\n\
      \    >>> Y = stats.lognorm(s=sigma, scale=np.exp(mu))\n    >>> x = np.linspace(*X.interval(0.999))\n\
      \    >>> y = Y.rvs(size=10000)\n    >>> ax.plot(x, X.pdf(x), label='X (pdf)')\n\
      \    >>> ax.hist(np.log(y), density=True, bins=x, label='log(Y) (histogram)')\n\
      \    >>> ax.legend()\n    >>> plt.show()\n\n    "
    _ctor_param:
      a: 0.0
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: lognorm
      seed: null
      shapes: s
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self, s,  loc=0, scale=1):\n    return\
      \ (s, ), loc, scale\n\ndef _parse_args_rvs(self, s,  loc=0, scale=1, size=None):\n\
      \    return self._argcheck_rvs(s,  loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \ s,  loc=0, scale=1, moments='mv'):\n    return (s, ), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: false
    a: 0.0
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: lognorm
    numargs: 1
    shapes: s
    xtol: 1.0e-14
  kwds:
    s: 0.954
    scale: !!python/object/apply:numpy.core.multiarray.scalar
    - !!python/object/apply:numpy.dtype
      args:
      - f8
      - false
      - true
      state: !!python/tuple
      - 3
      - <
      - null
      - null
      - null
      - -1
      - -1
      - 0
    - !!binary |
      AAAAAAAA8D8=
- !!python/object:scipy.stats._distn_infrastructure.rv_continuous_frozen
  a: 0.0
  args: !!python/tuple []
  b: .inf
  dist: !!python/object:scipy.stats._continuous_distns.weibull_min_gen
    __doc__: "Weibull minimum continuous random variable.\n\n    The Weibull Minimum\
      \ Extreme Value distribution, from extreme value theory\n    (Fisher-Gnedenko\
      \ theorem), is also often simply called the Weibull\n    distribution. It arises\
      \ as the limiting distribution of the rescaled\n    minimum of iid random variables.\n\
      \n    As an instance of the `rv_continuous` class, `weibull_min` object inherits\
      \ from it\n    a collection of generic methods (see below for the full list),\n\
      \    and completes them with details specific for this particular distribution.\n\
      \    \n    Methods\n    -------\n    rvs(c, loc=0, scale=1, size=1, random_state=None)\n\
      \        Random variates.\n    pdf(x, c, loc=0, scale=1)\n        Probability\
      \ density function.\n    logpdf(x, c, loc=0, scale=1)\n        Log of the probability\
      \ density function.\n    cdf(x, c, loc=0, scale=1)\n        Cumulative distribution\
      \ function.\n    logcdf(x, c, loc=0, scale=1)\n        Log of the cumulative\
      \ distribution function.\n    sf(x, c, loc=0, scale=1)\n        Survival function\
      \  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).\n   \
      \ logsf(x, c, loc=0, scale=1)\n        Log of the survival function.\n    ppf(q,\
      \ c, loc=0, scale=1)\n        Percent point function (inverse of ``cdf`` ---\
      \ percentiles).\n    isf(q, c, loc=0, scale=1)\n        Inverse survival function\
      \ (inverse of ``sf``).\n    moment(order, c, loc=0, scale=1)\n        Non-central\
      \ moment of the specified order.\n    stats(c, loc=0, scale=1, moments='mv')\n\
      \        Mean('m'), variance('v'), skew('s'), and/or kurtosis('k').\n    entropy(c,\
      \ loc=0, scale=1)\n        (Differential) entropy of the RV.\n    fit(data)\n\
      \        Parameter estimates for generic data.\n        See `scipy.stats.rv_continuous.fit\
      \ <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__\
      \ for detailed documentation of the\n        keyword arguments.\n    expect(func,\
      \ args=(c,), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)\n\
      \        Expected value of a function (of one argument) with respect to the\
      \ distribution.\n    median(c, loc=0, scale=1)\n        Median of the distribution.\n\
      \    mean(c, loc=0, scale=1)\n        Mean of the distribution.\n    var(c,\
      \ loc=0, scale=1)\n        Variance of the distribution.\n    std(c, loc=0,\
      \ scale=1)\n        Standard deviation of the distribution.\n    interval(confidence,\
      \ c, loc=0, scale=1)\n        Confidence interval with equal areas around the\
      \ median.\n\n    See Also\n    --------\n    weibull_max, numpy.random.Generator.weibull,\
      \ exponweib\n\n    Notes\n    -----\n    The probability density function for\
      \ `weibull_min` is:\n\n    .. math::\n\n        f(x, c) = c x^{c-1} \\exp(-x^c)\n\
      \n    for :math:`x > 0`, :math:`c > 0`.\n\n    `weibull_min` takes ``c`` as\
      \ a shape parameter for :math:`c`.\n    (named :math:`k` in Wikipedia article\
      \ and :math:`a` in\n    ``numpy.random.weibull``).  Special shape values are\
      \ :math:`c=1` and\n    :math:`c=2` where Weibull distribution reduces to the\
      \ `expon` and\n    `rayleigh` distributions respectively.\n\n    Suppose ``X``\
      \ is an exponentially distributed random variable with\n    scale ``s``. Then\
      \ ``Y = X**k`` is `weibull_min` distributed with shape\n    ``c = 1/k`` and\
      \ scale ``s**k``.\n\n    The probability density above is defined in the \"\
      standardized\" form. To shift\n    and/or scale the distribution use the ``loc``\
      \ and ``scale`` parameters.\n    Specifically, ``weibull_min.pdf(x, c, loc,\
      \ scale)`` is identically\n    equivalent to ``weibull_min.pdf(y, c) / scale``\
      \ with\n    ``y = (x - loc) / scale``. Note that shifting the location of a\
      \ distribution\n    does not make it a \"noncentral\" distribution; noncentral\
      \ generalizations of\n    some distributions are available in separate classes.\n\
      \n    References\n    ----------\n    https://en.wikipedia.org/wiki/Weibull_distribution\n\
      \n    https://en.wikipedia.org/wiki/Fisher-Tippett-Gnedenko_theorem\n\n    Examples\n\
      \    --------\n    >>> import numpy as np\n    >>> from scipy.stats import weibull_min\n\
      \    >>> import matplotlib.pyplot as plt\n    >>> fig, ax = plt.subplots(1,\
      \ 1)\n    \n    Calculate the first four moments:\n    \n    >>> c = 1.79\n\
      \    >>> mean, var, skew, kurt = weibull_min.stats(c, moments='mvsk')\n    \n\
      \    Display the probability density function (``pdf``):\n    \n    >>> x =\
      \ np.linspace(weibull_min.ppf(0.01, c),\n    ...                 weibull_min.ppf(0.99,\
      \ c), 100)\n    >>> ax.plot(x, weibull_min.pdf(x, c),\n    ...        'r-',\
      \ lw=5, alpha=0.6, label='weibull_min pdf')\n    \n    Alternatively, the distribution\
      \ object can be called (as a function)\n    to fix the shape, location and scale\
      \ parameters. This returns a \"frozen\"\n    RV object holding the given parameters\
      \ fixed.\n    \n    Freeze the distribution and display the frozen ``pdf``:\n\
      \    \n    >>> rv = weibull_min(c)\n    >>> ax.plot(x, rv.pdf(x), 'k-', lw=2,\
      \ label='frozen pdf')\n    \n    Check accuracy of ``cdf`` and ``ppf``:\n  \
      \  \n    >>> vals = weibull_min.ppf([0.001, 0.5, 0.999], c)\n    >>> np.allclose([0.001,\
      \ 0.5, 0.999], weibull_min.cdf(vals, c))\n    True\n    \n    Generate random\
      \ numbers:\n    \n    >>> r = weibull_min.rvs(c, size=1000)\n    \n    And compare\
      \ the histogram:\n    \n    >>> ax.hist(r, density=True, bins='auto', histtype='stepfilled',\
      \ alpha=0.2)\n    >>> ax.set_xlim([x[0], x[-1]])\n    >>> ax.legend(loc='best',\
      \ frameon=False)\n    >>> plt.show()\n    \n\n    "
    _ctor_param:
      a: 0.0
      b: .inf
      badvalue: .nan
      longname: null
      momtype: 1
      name: weibull_min
      seed: null
      shapes: c
      xtol: 1.0e-14
    _parse_arg_template: "\ndef _parse_args(self, c,  loc=0, scale=1):\n    return\
      \ (c, ), loc, scale\n\ndef _parse_args_rvs(self, c,  loc=0, scale=1, size=None):\n\
      \    return self._argcheck_rvs(c,  loc, scale, size=size)\n\ndef _parse_args_stats(self,\
      \ c,  loc=0, scale=1, moments='mv'):\n    return (c, ), loc, scale, moments\n"
    _random_state: *id001
    _stats_has_moments: true
    a: 0.0
    b: .inf
    badvalue: .nan
    moment_type: 1
    name: weibull_min
    numargs: 1
    shapes: c
    xtol: 1.0e-14
  kwds:
    c: 1.5
n_samples: 2000
